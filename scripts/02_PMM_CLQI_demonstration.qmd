
This qmd houses the example implementation of *PMM* and *CLQI*. 
The functions defined here will form the basis of how the functions for our simulation study will be written `03`, and our simulation study in `04`

Before we start, you must run `00` and `01`, but we removed unnecessary values each time for organizational purposes.
Here are them again. Have fun !

```{r}
set.seed(625)

my_sample <- 1000
weak_effects <- c(logit(0.1), log(1.1), log(0.7), log(0.85))
strong_effects <- c(logit(0.1), log(1.5), log(0.7), log(0.85))

num_imp <- 10 #number of imputations
generated_data_for_testing <- data_generating_mechanism(my_sample = my_sample,
                                                        beta_coefficients = weak_effects,
                                                        prop_missing_MCAR = 0.3,
                                                        min_val = 0,
                                                        max_val = q_999999)
```

# Predictive Mean Matching

Before we introduce the function for our implementation, we will go through how the `mice` package works here

```{r, eval=FALSE}
# mice requires the dataframe to only contain missing variable and its predictors
generated_data_for_PMM <- generated_data_for_testing |>
  dplyr::select(confounder, biomarker_MCAR, outcome, predictor) 

#perform the mice function!
PMM_test <- mice::mice(generated_data_for_PMM, 
                       method = "pmm", 
                       m = num_imp) 

#check that a dataset has been made: there should be no NA's
sum(is.na(complete(PMM_test, action = 1) |> dplyr::select(biomarker_MCAR)))
```

Second part: getting estimates and applying rubin rules

```{r, eval=FALSE}
# purrr function to get coefficients: let me break it down for you
PMM_coefficients <- purrr::map_dbl(1:num_imp, ~ { #we repeat this 10 times
  
  #extract the ith dataset (.x refers to the 1:num_imp)
  data_iteration <- complete(PMM_test, action = .x)
  
  #perform logistic regression
  log_reg_estimate <- glm(as.formula(formula_biomarker_MCAR), 
                          data = data_iteration,
                          family = "binomial") |>
    broom::tidy() |> #make it into a nice data frame
    filter(term == "biomarker_MCAR") |> #extract biomarker_MCAR row
    pull(estimate) #we only care about the estimate
   
  #this is not necessary, but for organization
  log_reg_estimate 
  }
)

# after this, we can perform rubin's rule for the estimate to check for bias
mean(PMM_coefficients) - weak_effects[2]
```

Alternatively, use map to extract a list of dataframes, which preserves data, but is computationally more intensive
HOWEVER, using tictoc, we can see that the time is barely anything.

```{r, eval=FALSE}
tictoc::tic()
PMM_regression_results <- purrr::map(1:num_imp, ~ { #we repeat this 10 times
  
  #extract the ith dataset (.x refers to the 1:num_imp)
  data_iteration <- complete(PMM_test, action = .x)
  
  #perform logistic regression
  log_reg_df <- glm(as.formula(formula_biomarker_MCAR),
                    data = data_iteration,
                    family = "binomial") |>
    broom::tidy() 
   
  #this is not necessary, but for organization
  log_reg_df 
  }
)
tictoc::toc()

PMM_regression_results
```

`PMM` is the function that returns a *list of regression results* after applying the algorithm
- Prior to applying the function, you must filter the data to the bare essentials, then use the correct formula text for the regression to run correctly. Purrr is used to make sure this doesn't take forever
- I will be adding a suppress message to the mice function


```{r}
PMM <- function(my_data_filtered, correct_formula, num_imp) {
  
  # Generate imputed datasets
  capture.output({ #the mice package has weird output that isn't relevant for us. This is largely ignored
    PMM_df <- mice::mice(my_data_filtered, 
                         method = "pmm", 
                         m = num_imp) 
  })
  
  # Run regression!
  PMM_regression_results <- purrr::map(1:num_imp, ~ { #we repeat this num_imp times
    
    #extract the ith dataset (.x refers to the 1:num_imp)
    data_iteration <- complete(PMM_df, action = .x)
    
    #perform logistic regression
    log_reg_df <- glm(as.formula(correct_formula),
                      data = data_iteration,
                      family = "binomial") |>
      broom::tidy() 
     
    #this is not necessary, but for organization
    log_reg_df 
    }
  )
  
  #make sure to return it!
  return(PMM_regression_results)
}
```

> Case 1: MCAR data with 10 imputations

```{r, eval=FALSE}
generated_data_MCAR <- generated_data_for_testing |>
  dplyr::select(confounder, biomarker_MCAR, outcome, predictor) 

PMM(my_data_filtered = generated_data_MCAR, 
    correct_formula = formula_biomarker_MCAR, 
    num_imp = 10)
```

> Case 2: MCAR data with 20 imputations

```{r, eval=FALSE}
generated_data_MCAR <- generated_data_for_testing |>
  dplyr::select(confounder, biomarker_MCAR, outcome, predictor) 

tictoc::tic()
PMM(my_data_filtered = generated_data_MCAR, 
    correct_formula = formula_biomarker_MCAR, 
    num_imp = 20)
tictoc::toc()
```

> Case 3: MAR data  with 10 imputations (Not implemented yet with MAR)

```{r, eval=FALSE}
generated_data_MAR <- generated_data_for_testing |>
  dplyr::select(confounder, biomarker_MAR, outcome, predictor) 

PMM(my_data_filtered = generated_data_MAR, 
    correct_formula = formula_biomarker_MAR, 
    num_imp = 10)
```

# Conditional Logistic Quantile Imputation (CLQI)

Same idea: we're going to demonstrate how CLQI works, then provide a function that combines everything

```{r}

```

