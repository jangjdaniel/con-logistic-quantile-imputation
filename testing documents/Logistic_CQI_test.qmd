```{r}
library(tidyverse)
library(missMethods)
library(quantreg)
```

Trying Logistic Quantile Regression: clear R history for this to work properly

```{r}
#initial data generation
set.seed(2025)

#skewed distribution for imputation testing
my_data <- data.frame(
  original_data = rchisq(1000, df = 5)) #can change to any other distribution: try F and gamma?

#rchisq(1000, df = 5)
#rgamma(1000, 4, rate = 3)
#rf(1000, 6, 4)

#rnorm(1000, mean = 0, sd = 4)

ggplot(data = my_data, aes(x=original_data)) +
  geom_density()
```

```{r}
#the bounds for our variable: this is just a toy example
min <- 0
max <- 14 #for the sake of demonstration, let's create this cutoff
count(my_data |> filter(original_data > 14)) #as we can see, 10 of the 1000 obs are out of the range

my_data <- my_data |>
  mutate(transformed_data = (log(original_data) - min) / (max - log(original_data)))

ggplot(data = my_data, aes(x=transformed_data)) +
  geom_density()
```

```{r}
#mechanism to make missing data (from https://cran.r-project.org/web/packages/missMethods/vignettes/Generating-missing-values.html)
make_missing <- delete_MCAR(my_data, 0.5, "original_data") #half the data is gone now

#likely a better way to approach this, but I'm lazy. R has gotten better with for loops
for(i in 1:nrow(make_missing)) {
 #ie if [i] is NA, then make transformed_data NA as well 
}
```


```{r}
#conditional quantile function with my_data and transformed_data!
```


```{r}
#this time, the fitted values can only be within a certain range, so when un-transforming it, we should never observe a value outside of (min, max)
```


